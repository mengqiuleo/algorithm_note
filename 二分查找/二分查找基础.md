[TOC]



## 最基础的二分

### 704.二分查找

题目链接：[704.二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 -1。

**示例 1**：

```text
输入: nums = [-1, 0, 3, 5, 9, 12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2**：

```text
输入: nums = [-1, 0, 3, 5, 9, 12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示**：

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]` 之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]` 之间。

**解题思路**

- 循环可以继续的条件是 `left <= right`，表示当 `left` 和 `right` 重合的时候，仍然继续查找。

```js
var search = function(nums, target) {
    let left = 0,right = nums.length - 1;
    while(left <= right){
        let mid = left + Math.floor((right - left)/2);
        if(nums[mid] > target){
            right = mid - 1;
        } else if(nums[mid] < target) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
};
```

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。



**左闭右开**

```js
var search = function(nums, target) {
    // right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间
    let left = 0, right = nums.length;    
    // 当left=right时，由于nums[right]不在查找范围，所以不必包括此情况
    while (left < right) {
        let mid = left + Math.floor((right - left)/2);
        // 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；
        // 由于right本来就不在查找范围内，所以将右边界更新为中间值，如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围
        if (nums[mid] > target) {
            right = mid;  // 去左区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```



## 把区间分成两个部分的二分

### 引入

**每一次我们把一定不存在问题答案的区间去掉就可以了**。因此我们只需要 **把区间分成两个部分**。

> 「力扣」上有一些问题具有这样的特点。问题的答案可能是 `mid` 位置的值。具体来说，`mid` 是不是问题的答案，由 `mid` 的左边或者右边是否存在答案决定：
>
> - 如果 `mid` 的左边（或者右边）不存在答案，那么 `mid` 就是我们要找的问题的答案；
> - 如果 `mid` 的左边（或者右边）存在答案，那么 `mid` 不是我们要找的问题的答案。



### 例题

「力扣」第 34 题：在排序数组中查找元素的第一个和最后一个位置

比如现在，我们需要查找第一个出现4的位置：

如果当前 `mid` 看到的元素就等于 4，此时不能确定 4 就是数组当中第 1 次出现的位置。如果我们知道 4 的左边没有 4，オ可以确定此时 `mid` 是「数字 4 第 1 次出现的位置」。 但可以确定的是： 4 的右边一定不是「数字 4 第 1 次出现的位置」。



「力扣」第 35 题：搜索插入位置

```text
输入: [1, 3, 5, 6], 2
输出: 1
```

题目中因为找不到目标元素，所以需要我们返回第 1 个 **大于** 目标元素 2 的下标，因此返回 1。

「查找第 1 次出现的位置」和「查找第一个大于等于 `target` 的元素的位置」这样的问题，如果根据 `mid` 位置的值，把待搜索区间分成 3 个部分，不能够确定问题的答案一定在其中某一个区间里，但一定可以确定的是：**问题的答案一定不在其中某一个区间里**。 



例 3：「力扣」第 69 题：平方根（简单）

根据题意，我们要找的是平方以后 **小于等于** x 的最大正整数 a。用「二分查找」找到了一个整数 a，如果它的平方 **严格小于** x，此时 a 还不能确定是题目的答案，只有当我们可以确定，所有大于 a 的值都不是解的时候，a 才是答案。

例如：

- 9 的平方根，3^2 = 9，3 是 9 的平方根；
- 8 的平方根，2^2 = 4 < 8，3^2 = 9 > 8，因此 2 是（本题规定下） 8 的平方根。



### 解决方案

> 把区间分成两个部分，去掉一定不存在目标元素的区间，只在有可能存在目标元素的区间里查找。这样当 `left` 与 `right` 重合的时候，我们才可以确定找到了目标元素（或者确定搜索区间里不存在目标元素）。



如果当前猜的数 `nums[mid]` 符合某个性质，我们还不能确定它一定就是我们要找的元素，必须向左边（或者向右边）继续看下去，才能确定 `nums[mid]` 是不是我们要找的元素。

每一次排除掉一定不存在问题答案的区间，把 `left` 和 `right` 根据 `mid` 看到的值逐渐向中间靠拢，直到它们重合。

根据这种思路，我们就可以肯定：

- 找到了问题的答案（`left` 和 `right` 重合的位置就是问题的答案）；
- 或者搜索范围里不存在问题的答案。

**为什么二分查找分三种情况讨论的结果需要合并**

- `while (left < right)` 表示当 `left` 与 `right` 重合的时候停止搜索，这样我们就不用思考返回 `left` 还是 `right`；
- `while` 里面只写两个分支，即只有 `if` 和 `else`，表示：非此即彼，把其中一种情况考虑好，不满足这种情况的区间就是上一个区间的反面区间。

这一节只需要大家消化一个知识点：只有分成两个区间，退出循环以后，`left` 和 `right` 才会重合。



## 两种模板

**while (left <= right)**

看到 `while (left <= right)` 这种写法的朋友们，你一定会看到「大佬」们这么用：声明一个 `ans` 变量，一定会出现在 `if` 和 `else` 分支里的其中一个。

力扣35题官方题解

```js

var searchInsert = function(nums, target) {
    const n = nums.length;
    let left = 0, right = n - 1, ans = n;
    while (left <= right) {
        let mid = ((right - left) >> 1) + left;
        if (target <= nums[mid]) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
};
```

- 题目要我们找的是：**第 1 个大于等于 `target` 的元素的位置**，当看到一个元素 `nums[mid]` 大于等于 `target` 的时候，`nums[mid]` 有可能就是我们要找的，所以把 `ans` 先保存为 `mid`；

- 数组的长度 `n` ，也就是数组的最后一个元素的下一个位置也有可能是答案，所以一开始的时候设置 `ans = n`；

- `if` 和 `else` 里面，不管怎么样，`left` 和 `right` 的设置都需要 + 1 或者 -1。设置 `left = mid + 1`，说明下一轮向右边找，设置 `right = mid - 1` ，说明下一轮向左边找。这是因为：**`mid` 如果有可能是解的话，因为有了 `ans` 的设置，一定不会丢失最优解**；

- 当 `left == right` 重合的时候，`left` 位置的值还没有看到(还没有被测试过)，所以要继续找下去，因此循环可以继续的条件是 `while (left <= right)`；

- 最后返回的是 `ans` 哦，不是 `left` 或者 `right` 的任何一个。

> **如果当前猜的那个数 `nums[mid]` 符合某个性质，我们还不能确定它一定就是我们要找的元素，必须向左边（或者向右边）继续看下去，才能确定 `nums[mid]` 是不是我们要找的元素**。









**while (left < right)**

力扣35题题解

既然 `len` 也有可能是答案，可以在初始化的时候，把 `right` 设置成 `len`，在一开始的时候就不需要特殊判断了。

情况 1：如果当前 mid 看到的数值严格小于 target，那么 mid 以及 mid 左边的所有元素就一定不是「插入元素的位置」，因此下一轮搜索区间是 [mid + 1..right]，下一轮把 left 移动到 mid + 1 位置，因此设置 left = mid + 1；
情况 2：否则，如果 mid 看到的数值大于等于 target，那么 mid 可能是「插入元素的位置」，mid 的右边一定不存在「插入元素的位置」。如果 mid 的左边不存在「插入元素的位置」，我们才可以说 mid 是「插入元素的位置」。因此下一轮搜索区间是 [left..mid]，下一轮把 right 移动到 mid 位置，因此设置 right = mid。

```js
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

