## 力扣34题

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。



示例 1：

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```


示例 2：

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```


示例 3：

```
输入：nums = [], target = 0
输出：[-1,-1]
```



### 解题思路



```js
var searchRange = function(nums, target) {
  const findFirstPosition = function(nums,target){
    let left = 0,right = nums.length - 1;
    while(left < right){
      let mid = left + Math.floor((right - left)/2);
      if(nums[mid] < target){ //如果中间值小于目标值，那么左边一定不是解
        left = mid + 1;
      }else { //与上面的if相反，mid >= target,答案整体位于左边,并且mid可能等于target
        //nums[mid] === target 可能是
        right = mid;
      }
    }

    //退出循环后，left=right，但其实此时mid并没有判断，需要再判断一次
    if(nums[right] === target){
      return left;
    }
    return -1;
  }

  const findLastPosition = function(nums,target){
    let left = 0,right = nums.length - 1;
    while(left < right){
      let mid = left + Math.floor((right - left + 1)/2);
      if(nums[mid] > target){
        right = mid - 1;
      }else{
        //nums[mid] <= target
        left = mid;
      }
    }
    return left;
  }

  let len = nums.length;
  if(len === 0){
    return [-1,-1];
  }
  let firstPosition = findFirstPosition(nums,target)
  if(firstPosition === -1){
    return [-1,-1]
  }
  let lastPosition = findLastPosition(nums,target)
  return [firstPosition,lastPosition]
};
```







## 35.题目描述

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1：**

```text
输入: [1, 3, 5, 6], 5
输出: 2
```

**示例 2：**

```text
输入: [1, 3, 5, 6], 2
输出: 1
```

**示例 3：**

```text
输入: [1, 3, 5, 6], 7
输出: 4
```

**示例 4：**

```text
输入: [1, 3, 5, 6], 0
输出: 0
```

**示例 5:**

```text
输入: nums = [1], target = 0
输出: 0
```





**题解**

```js
var searchInsert = function(nums, target) {
  let len = nums.length;
  //特殊判断
  if(nums[len - 1] < target){
    return len;
  }

  let left = 0,right = len - 1;
  // while(left < right){
  //   let mid = left + Math.floor((right - left)/2)
  //   if(nums[mid] > target){
  //     right = mid;
  //   }else if(nums[mid] < target){
  //     left = mid + 1;
  //   }else if(nums[mid] === target){
  //     right = mid;
  //   }
  // }
  while(left < right){
    let mid = left + Math.floor((right - left)/2);
    if(nums[mid] >= target){
      right = mid;
    }else {
      left = mid + 1;
    }
  }
  return left;
};
```









## [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

```js
var triangleNumber = function(nums) {
  let count = 0;
  nums.sort((a,b) => a-b);
  let len = nums.length;
  for(let i = 0;i < len-2;i++)
  {
      for(let j = i+1;j < len-1;j++)
      {
          let target = nums[i] + nums[j];
          let left = j + 1, right = len - 1;
          if(nums[right] < target){
            count += right - j;
            continue;
          }
          while(left < right){
            let mid = Math.floor((right + left)/2);
            if(nums[mid] < target){
              left = mid + 1;
            } else {
              right = mid;
            }
          }
          if(nums[left] < target){
            count += left - j;
          }else {
            count += left - 1 - j;
          }
      }
  }
  return count;
};
```







> 个人总结：
>
> 找不一定能找到
>
> 求一定能求出来
>
> 
>
> **找右边界**
>
> 首先是 nums[mid] > target ,因为要往左边逼，所以就是 right = mid - 1
>
> 那么 要加1，防止死循环